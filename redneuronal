import pandas as pd
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.regularizers import l1_l2
from sklearn.model_selection import train_test_split, KFold
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import accuracy_score

# Cargar los datos
data = pd.read_csv('ruta/a/data.csv')  # Asegúrate de cambiar esto por la ruta correcta en Dropbox

# Preprocesamiento de los datos
scaler = MinMaxScaler(feature_range=(1, 50))
scaled_data = scaler.fit_transform(data)

# Dividir los datos en conjuntos de entrenamiento y prueba
X = scaled_data[:, :-1]
y = scaled_data[:, -1]

# Crear el modelo de red neuronal con regularización y dropout
def create_model():
    model = Sequential()
    model.add(Dense(10, input_dim=4, activation='relu', kernel_regularizer=l1_l2(l1=0.01, l2=0.01)))
    model.add(Dropout(0.5))
    model.add(Dense(8, activation='relu', kernel_regularizer=l1_l2(l1=0.01, l2=0.01)))
    model.add(Dropout(0.5))
    model.add(Dense(1, activation='linear'))
    model.compile(loss='mean_squared_error', optimizer='adam', metrics=['accuracy'])
    return model

# Validación cruzada
kf = KFold(n_splits=5)
for train_index, test_index in kf.split(X):
    X_train, X_test = X[train_index], X[test_index]
    y_train, y_test = y[train_index], y[test_index]

    model = create_model()
    model.fit(X_train, y_train, epochs=50, batch_size=10)

    # Evaluar el modelo
    predictions = model.predict(X_test)
    accuracy = accuracy_score(y_test, predictions.round())
    print(f'Precisión media del modelo: {accuracy}')

# Predecir el siguiente bloque de números
# Aquí deberás proporcionar los últimos 4 números del último bloque conocido
next_number_prediction = model.predict([[ultimo_numero1, ultimo_numero2, ultimo_numero3, ultimo_numero4]])
next_number_scaled = scaler.inverse_transform(next_number_prediction)[0]
print(f'El siguiente número en la secuencia es: {next_number_scaled}')
